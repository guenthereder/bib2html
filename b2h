#!/usr/bin/perl

use strict;
use warnings;
use File::Path;
use File::Temp;
use Text::BibTeX;
#use Text::Template;
use t2h;
use Data::Dumper;

my $DO_SELECTED_ONLY = 1;

package Item;

sub new {
    my ($class, $bibentry) = @_;
    my $self = {'bibentry' => $bibentry};
    bless $self, $class;
    $self;
}

sub exists {
    my ($self, $field) = @_;
    return 1 if $self->{'bibentry'}->exists($field);
    return 1 if grep {$_ eq $field} qw{f_authors f_atitle};
    return 0;
}

sub get_plain {
    my ($self, $field) = @_;

    return $self->{'bibentry'}->get($field)
        if ($self->{'bibentry'}->exists($field));

    if ($field eq 'f_authors') {
        return $self->{'bibentry'}->format_authors;
    } elsif ($field eq 'f_atitle') {
        return $self->{'bibentry'}->format_atitle;
    }
    return undef;
}

sub get {
    my ($self, $field) = @_;
    my $value = $self->get_plain($field);

    return ::tex_to_html($value);
}

sub key { return shift->{'bibentry'}->key; }
sub type { return shift->{'bibentry'}->type; }


package main;

use constant BIBFILENAME => 'b2h.bib';

sub create_bbl {
    open F, ">", 'dummy.tex' or die ("Cannot open tex file for output: $!\n");
    print F << '    EOF';
    \documentclass{article}
    \bibliographystyle{plain}
    %\bibliographystyle{acm}
    \begin{document}
    \bibliography{b2h}
    \nocite{*}
    \end{document}
    EOF
    close F;

    open(my $oldout, ">&STDOUT") or die "Can't dup STDOUT: $!\n";
    open(STDOUT, '>', "/dev/null") or die "Can't redirect STDOUT: $!\n";

    system(qw{latex dummy}) == 0 or die "latex run failed: $?\n";
    system(qw{bibtex dummy}) == 0 or die "bibtex run failed: $?\n";

    open(STDOUT, ">&", $oldout) or die "Can't dup \$oldout: $!";
    close($oldout);
}

sub trim($) {
    my ($s) = @_;
    $s =~ s/^\s*//;
    $s =~ s/\.?\s*$//;
    return $s;
}

sub sanitize_key($) {
    my ($k) = @_;

    $k =~ s/[^-A-Za-z0-9_]/_/g;
    $k =~ s/^/bib-/;
    return $k;
}

sub latex_format_bibs {
    create_bbl;
    my $bblitems = {};
    open F, "<", 'dummy.bbl' or die ("Cannot open bbl file for input: $!\n");
    {
        local $/="";
        while (<F>) {
            if (/^\\begin\{thebibliography\}/) {
                next;
            } elsif (/^\\bibitem(?:\[.*?\])?\{(.*)\}/) {
                $bblitems->{$1} = $_;
            } elsif (/^\\end\{thebibliography\}/) {
                last;
            } else {
                warn("Unexpected token in bbl: $_\n");
            }
        };
    };
    my $formatted = {};
    for my $k (keys %$bblitems) {
        my @tokens = split /\\newblock/, $bblitems->{$k};
        if (scalar @tokens >= 2) {
            my $t1 = shift @tokens;
            my $t2 = shift @tokens;
            my ($bibkey, $authors) = split(/\n/, $t1, 2);

            my $idbibkey = sanitize_key($k);
            my $lines = [];
            push @$lines, sprintf('<div class="bibitem"><a id="%s" href="#%s">%s</a></div>', $idbibkey, $idbibkey, trim(tex_to_html($k)));
            push @$lines, sprintf('<div class="title">%s</div>', trim(tex_to_html($t2)));
            push @$lines, sprintf('<div class="authors">%s</div>', trim(tex_to_html($authors)));
            push @$lines, sprintf('<div class="reference-info">%s</div>', trim(tex_to_html(join('\newblock', @tokens))));

            $formatted->{$k} = $lines;
        }
    }
    return $formatted;
}

my $tmpdir;
END { chdir "/"; File::Path::remove_tree($tmpdir, {verbose => 0}) if defined ($tmpdir); }
$tmpdir = File::Temp->newdir(CLEANUP => 0);

open BIB, '>', $tmpdir."/".BIBFILENAME or die $!;
print BIB while (<>);
close BIB;

chdir($tmpdir) or die ("Cannot chdir to $tmpdir.\n");

my $bbl = latex_format_bibs;
#print Data::Dumper->Dump([$bbl]);

my $bib = new Text::BibTeX::File;
$bib->open(BIBFILENAME) or die "Cannot load bibfile: $!\n";
$bib->set_structure('Bib');

#sub do_tmpl {
#    my ($txt, $item, $vars) = @_;
#
#    my $h = { map { $_ => $item->exists($_) ? $item->get($_) : undef } @$vars };
#
#    my $res = Text::Template::fill_in_string(
#        $txt,
#        PREPEND => q{use strict;},
#        HASH => $h);
#    unless (defined $res) {
#        my $bibtexkey = $item->key;
#        warn "Couldn't construct template: $Text::Template::ERROR for $bibtexkey.\n";
#    };
#    return $res;
#}
#
#sub format_inproceedings($) {
#    my $entry = shift;
#    my @vars = qw{f_atitle f_authors booktitle pages address month year};
#
#    my $varlist = join(' ', map {'$'.$_} @vars);
#    my $template = "{ use vars qw{$varlist}; }\n";
#    $template .= <<'    EOF';
#    <strong>{$f_atitle}</strong><br />
#    <em>{$f_authors}</em><br />
#    In {$booktitle}{ if (defined($pages)) {
#        $OUT .= ", pp {$pages}";
#      }
#    }<br />
#    {$address}, {$month}, {$year}
#
#    EOF
#
#    return do_tmpl($template, $entry, \@vars);
#};

sub format_entry($) {
    my $entry = shift;

    my $bibtexkey = $entry->key;
    my @res;

    my $type = $entry->type;
    my $idbibkey = sanitize_key($bibtexkey);
    push @res, "<div class=\"publication $type\">";
    push @res, @{$bbl->{$bibtexkey}};

    my @misc;
    if ($entry->exists('www_links')) {
        for my $line (split /\s*\|\s*/, $entry->get_plain('www_links')) {
            my ($desc, $link) = split(/:/, $line, 2);
            if ($desc eq "raw") {
                push @misc, $link;
            } elsif (defined $link) {
                push @misc, sprintf('<a href="%s">%s</a>', trim(tex_to_html($link)), trim(tex_to_html($desc)));
            } else {
                warn("Undefined link for $desc in $bibtexkey.\n");
            }
        }
    };
    if ($entry->exists('doi')) {
        my $doi = $entry->get_plain('doi');
        push @misc, sprintf('<a class="doi" href="http://dx.doi.org/%s">%s</a>', $doi, $doi);
    };

    if (scalar @misc || $entry->exists('abstract')) {
        push @res, '<div class="misc">';
        if ($entry->exists('abstract')) {
            push @res, sprintf('<div class="abstract_link"><a href="javascript:void(0)" onclick="javascript:abstract_visible(\'%s\')">abstract</a>%s</div>', $idbibkey, (scalar @misc ? ';' : ''));
        };
        push @res, join(";\n", @misc);
        push @res,'</div>';
    };

    if ($entry->exists('abstract')) {
        push @res, sprintf('<div id="abstract_%s" class="abstract">', $idbibkey);
        push @res, $entry->get('abstract');
        push @res, '</div>';
    };
    push @res, "</div>\n";

    return join("\n", @res);
};

my $entries = {};
my %month2number = (
    'January'   =>  1,
    'February'  =>  2,
    'March'     =>  3,
    'April'     =>  4,
    'May'       =>  5,
    'June'      =>  6,
    'July'      =>  7,
    'August'    =>  8,
    'September' =>  9,
    'October'   => 10,
    'November'  => 11,
    'December'  => 12 );

while (my $entry = new Text::BibTeX::Entry $bib) {
    next unless $entry->parse_ok && $entry->metatype == BTE_REGULAR;
    my $h = {};

    my $i = new Item($entry);
    $entries->{$i->key} = $h;

    my $is_selected = $i->exists('www_selected') && $i->get_plain('www_selected');
    if ($DO_SELECTED_ONLY && !$is_selected) {
        delete $entries->{$i->key};
        next;
    };

    my $year = $i->exists('year') ? $i->get_plain('year') : "unspecified";
    my $month = $i->exists('month') ? $month2number{$i->get_plain('month')} : undef;
    $month = 0 unless defined $month;
    $h->{'html'} = format_entry($i);
    $h->{'year'} = $year;
    $h->{'sort'} = sprintf("%s-%02d-%s", $year, $month, $i->key);
}

my $prev_year = '';
print <<EOF;
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html 
 PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style type="text/css">
.publication:before {
  float:left;
  width:25px;
  margin-left:-25px;
  font-size:24px;
  font-weight:bold;
  content: '\\2022';
}
.publication { margin: 10px 0 20px 30px; }
h2.year {margin-bottom:10px}
#abstract_mask {
  -moz-opacity: 0;
  opacity: 0;
  filter: alpha(opacity=0);
  z-index: 1;
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0px;
  left: 0px;
  display: none;
}
.abstract_link { display: none; }
.abstract {
  padding-left:20px;
  padding-right:20px;
  padding-top:10px;
  padding-bottom:10px;
  display: block;
  background-color: #ffffff;
  /* display: none; */
  /* position: absolute; */
  /* left: 120px; */
  /* z-index: 1; */
  /* border: #000 1px solid; */
  /* width: 50%; */
}
.bibitem:before { content: "["; }
.bibitem:after { content: "]"; }
.bibitem { font-size:small; }
.bibitem a { color:gray; }
.title { font-weight:bold; }
.authors { font-variant: small-caps; }
a.doi:before { content: "doi:"; }
a.doi { color:gray; font-family:"monospace" }
.misc { font-size:small;}
</style>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
</head>
<body>
<div id="abstract_mask"></div>
EOF
for my $key (sort {- ($entries->{$a}->{'sort'} cmp $entries->{$b}->{'sort'}) } keys %$entries) {
    my $i = $entries->{$key};
    if ($prev_year ne $i->{'year'}) {
        $prev_year = $i->{'year'};
        print "<h2 class=\"year\">$prev_year</h2>\n";
    };
    print $i->{'html'};
}
print <<EOF;
</body>
<script type="text/javascript">
  <!--
    hide_abstracts();
    var visible_abstract = 0;

    function hide_abstracts() {
      all_divs = document.getElementsByTagName("div");
      for (var i = 0; i < all_divs.length; i++) {
        if (all_divs[i].className == "abstract_link") {
          all_divs[i].style.display = "inline";
        } else if (all_divs[i].className == "abstract") {
          all_divs[i].style.display = "none";
          all_divs[i].style.position = "absolute";
          all_divs[i].style.left = "60px";
          all_divs[i].style.zIndex = 1;
          all_divs[i].style.border = "#000 1px solid";
          all_divs[i].style.width = "50%";
        }
      }
    }

    function abstract_visible(id) {
      var m = document.getElementById("abstract_mask");
      if (visible_abstract) {
        var t = document.getElementById("abstract_"+visible_abstract);
        t.style.display = "none";
        if (m) {
          m.style.display = "none";
        }
        if (visible_abstract == id) {
          visible_abstract = 0;
          return;
        }
        visible_abstract = 0;
      }
      var e = document.getElementById("abstract_"+id);
      if (e) {
         e.style.display = "block";
         visible_abstract = id;
         if (m) {
           m.onclick = function() { abstract_visible(id); };
           m.style.display = "block";
         }
      }
    }
    -->
</script>
</html>
EOF

# vim:set et ts=4 sw=4 st=4:
