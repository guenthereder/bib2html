#!/usr/bin/perl

# convert bibtex files to html

# Copyright (c) 2014 Peter Palfrader <peter@palfrader.org>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use strict;
use warnings;
use File::Path;
use File::Temp;
use Text::BibTeX;
#use Text::Template;
use t2h;
use HTML::Entities;
use Getopt::Long;


package Item;

sub new {
    my ($class, $bibentry) = @_;
    my $self = {'bibentry' => $bibentry};
    bless $self, $class;
    $self;
}

sub exists {
    my ($self, $field) = @_;
    return 1 if $self->{'bibentry'}->exists($field);
    return 1 if grep {$_ eq $field} qw{f_authors f_atitle};
    return 0;
}

sub get_plain {
    my ($self, $field) = @_;

    return $self->{'bibentry'}->get($field)
        if ($self->{'bibentry'}->exists($field));

    if ($field eq 'f_authors') {
        return $self->{'bibentry'}->format_authors;
    } elsif ($field eq 'f_atitle') {
        return $self->{'bibentry'}->format_atitle;
    }
    return undef;
}

sub get {
    my ($self, $field) = @_;
    my $value = $self->get_plain($field);

    return ::tex_to_html($value);
}

sub key { return shift->{'bibentry'}->key; }
sub type { return shift->{'bibentry'}->type; }

sub print_s {
    my ($self) = @_;
    my $be = $self->{'bibentry'};
    my $clone = Text::BibTeX::Entry->new;

    $clone->set_metatype(&Text::BibTeX::BTE_REGULAR);
    $clone->set_type($be->type);
    $clone->set_key($be->key);
    for my $k (@{$be->fieldlist}) {
        $clone->set($k, $be->get($k));
    }

    $clone->delete(qw{owner timestamp www_links www_selected file abstract});
    my $s = $clone->print_s;
    $s =~ s/\n*$//;
    return $s;
}

package main;

use constant BIBFILENAME => 'b2h.bib';
my $MONTH2NUMBER = {
                'January'   =>  1,
                'February'  =>  2,
                'March'     =>  3,
                'April'     =>  4,
                'May'       =>  5,
                'June'      =>  6,
                'July'      =>  7,
                'August'    =>  8,
                'September' =>  9,
                'October'   => 10,
                'November'  => 11,
                'December'  => 12 };

sub htmlize {
    my ($txt) = @_;

    return encode_entities($txt);
}

sub create_bbl {
    open F, ">", 'dummy.tex' or die ("Cannot open tex file for output: $!\n");
    print F << '    EOF';
    \documentclass{article}
    \bibliographystyle{plain}
    %\bibliographystyle{acm}
    \begin{document}
    \bibliography{b2h}
    \nocite{*}
    \end{document}
    EOF
    close F;

    open(my $oldout, ">&STDOUT") or die "Can't dup STDOUT: $!\n";
    open(STDOUT, '>', "/dev/null") or die "Can't redirect STDOUT: $!\n";

    system(qw{latex dummy}) == 0 or die "latex run failed: $?\n";
    system(qw{bibtex dummy}) == 0 or die "bibtex run failed: $?\n";

    open(STDOUT, ">&", $oldout) or die "Can't dup \$oldout: $!";
    close($oldout);
}

sub trim($) {
    my ($s) = @_;
    $s =~ s/^\s*//;
    $s =~ s/\.?\s*$//;
    return $s;
}

sub sanitize_key($) {
    my ($k) = @_;

    $k =~ s/[^-A-Za-z0-9_]/_/g;
    $k =~ s/^/bib-/;
    return $k;
}

sub html_format_bibs {
    create_bbl;
    my $bblitems = {};
    open F, "<", 'dummy.bbl' or die ("Cannot open bbl file for input: $!\n");
    {
        local $/="";
        while (<F>) {
            if (/^\\begin\{thebibliography\}/) {
                next;
            } elsif (/^\\bibitem(?:\[.*?\])?\{(.*)\}/) {
                $bblitems->{$1} = $_;
            } elsif (/^\\end\{thebibliography\}/) {
                last;
            } else {
                warn("Unexpected token in bbl: $_\n");
            }
        };
    };
    my $formatted = {};
    for my $k (keys %$bblitems) {
        my @tokens = split /\\newblock/, $bblitems->{$k};
        if (scalar @tokens >= 2) {
            my $t1 = shift @tokens;
            my $t2 = shift @tokens;
            my ($bibkey, $authors) = split(/\n/, $t1, 2);

            my $idbibkey = sanitize_key($k);
            my $lines = [];
            push @$lines, sprintf('<div class="bibitem"><a id="%s" href="#%s">%s</a></div>', $idbibkey, $idbibkey, trim(tex_to_html($k)));
            push @$lines, sprintf('<div class="title">%s</div>', trim(tex_to_html($t2)));
            push @$lines, sprintf('<div class="authors">%s</div>', trim(tex_to_html($authors)));
            push @$lines, sprintf('<div class="reference-info">%s</div>', trim(tex_to_html(join('\newblock', @tokens))));

            $formatted->{$k} = $lines;
        }
    }
    return $formatted;
}

sub entry_add_extra_info($$) {
    my ($base_info, $entry) = @_;

    my $bibtexkey = $entry->key;
    my @res;

    my $type = $entry->type;
    my $idbibkey = sanitize_key($bibtexkey);
    push @res, "<div class=\"publication $type\">";
    push @res, @{$base_info};

    my @misc;
    if ($entry->exists('www_links')) {
        for my $line (split /\s*\|\s*/, $entry->get_plain('www_links')) {
            my ($desc, $link) = split(/:/, $line, 2);
            if ($desc eq "raw") {
                push @misc, $link;
            } elsif (defined $link) {
                push @misc, sprintf('<a href="%s">%s</a>', trim(tex_to_html($link)), trim(tex_to_html($desc)));
            } else {
                warn("Undefined link for $desc in $bibtexkey.\n");
            }
        }
    };
    if ($entry->exists('doi')) {
        my $doi = $entry->get_plain('doi');
        push @misc, sprintf('<a class="doi" href="http://dx.doi.org/%s">%s</a>', $doi, $doi);
    };

    if (scalar @misc || $entry->exists('abstract')) {
        push @res, '<div class="misc">';
        if ($entry->exists('abstract')) {
            push @res, sprintf('<div class="block_link"><a href="javascript:void(0)" onclick="javascript:block_visible(\'abstract_%s\')">abstract</a>  &mdash; </div>', $idbibkey);
        };
        push @res, sprintf('<div class="block_link"><a href="javascript:void(0)" onclick="javascript:block_visible(\'bibtex_%s\')">bibtex</a>%s</div>', $idbibkey, (scalar @misc ? ' &mdash; ' : ''));
        push @res, join(" &mdash;\n", @misc);
        push @res,'</div>';
    };

    if ($entry->exists('abstract')) {
        push @res, sprintf('<div id="abstract_%s" class="abstract">%s</div>', $idbibkey, $entry->get('abstract'));
    };

    push @res, sprintf('<div id="bibtex_%s" class="bibtex">%s</div>', $idbibkey, htmlize($entry->print_s()));

    push @res, "</div>\n";

    return join("\n", @res);
};

sub setup_bib {
    my ($tmpdir) = @_;

    open BIB, '>', $tmpdir."/".BIBFILENAME or die $!;
    print BIB while (<>);
    close BIB;
}

sub open_bib {
    my $b = new Text::BibTeX::File;
    $b->open(BIBFILENAME) or die "Cannot load bibfile: $!\n";
    $b->set_structure('Bib');
    return $b;
};

sub prepare_entries {
    my $bibentries_baseinfo = html_format_bibs;
    my $bib = open_bib();
    my ($params) = @_;
    my $entries = {};
    while (my $entry = new Text::BibTeX::Entry $bib) {
        next unless $entry->parse_ok && $entry->metatype == BTE_REGULAR;
        my $h = {};

        my $i = new Item($entry);
        $entries->{$i->key} = $h;

        my $is_selected = $i->exists('www_selected') && $i->get_plain('www_selected');
        if (!$params->{'all'} && !$is_selected) {
            delete $entries->{$i->key};
            next;
        };

        my $year = $i->exists('year') ? $i->get_plain('year') : "unspecified";
        my $month = $i->exists('month') ? $MONTH2NUMBER->{$i->get_plain('month')} : undef;
        $month = 0 unless defined $month;
        $h->{'html'} = entry_add_extra_info($bibentries_baseinfo->{$i->key}, $i);
        $h->{'year'} = $year;
        $h->{'sort'} = sprintf("%s-%02d-%s", $year, $month, $i->key);
    }
    return $entries;
}


my $params = {};
Getopt::Long::config('bundling');
if (!GetOptions (
    'help'     =>  \$params->{'help'},
    'all'      =>  \$params->{'all'},
    'no-frame' =>  \$params->{'no-frame'},
    'no-css'   =>  \$params->{'no-css'},
    'no-js'    =>  \$params->{'no-js'},
    )) {
    die "$PROGRAM_NAME: Usage: $PROGRAM_NAME [options] <bibfile> [<bibfile> ..]\n";
};
if ($params->{'help'}) {
    print "$PROGRAM_NAME: Usage: $PROGRAM_NAME [options] <bibfile> [<bibfile> ..]\n";
    print "Options:\n";
    print "  --all      Include all bibitems, not just those with www_selected set.\n";
    print "  --help     Print this help.\n";
    print "  --no-frame Do not print the html header/body frame.\n";
    print "  --no-css   Do not print any CSS definitions.\n";
    print "  --no-js    Do not print any JS code.\n";
    exit(0);
};


my $tmpdir;
END { chdir "/"; File::Path::remove_tree($tmpdir, {verbose => 0}) if defined ($tmpdir); }
$tmpdir = File::Temp->newdir(CLEANUP => 0);

setup_bib($tmpdir);
chdir($tmpdir) or die ("Cannot chdir to $tmpdir.\n");
my $entries = prepare_entries($params);

my $css = << 'EOF';
.publication:before {
  float:left;
  width:25px;
  margin-left:-25px;
  font-size:24px;
  font-weight:bold;
  content: '\2022';
}
.publication { margin: 10px 0 20px 30px; }
h2.year {margin-bottom:10px}
#abstract_mask {
  -moz-opacity: 0;
  opacity: 0;
  filter: alpha(opacity=0);
  z-index: 1;
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0px;
  left: 0px;
  display: none;
}
.block_link { display: none; }
.abstract {
  padding-left:20px;
  padding-right:20px;
  padding-top:10px;
  padding-bottom:10px;
  display: block;
  background-color: #ffffff;
  /* display: none; */
  /* position: absolute; */
  /* left: 60px; */
  /* z-index: 1; */
  /* border: #000 1px solid; */
  /* width: 50%; */
}
.bibtex {
  padding-left:20px;
  padding-right:20px;
  padding-top:10px;
  padding-bottom:10px;
  display: block;
  background-color: #ffffff;
  font-family: "monospace";
  font-size: small;
  white-space: pre;
  display: none;
  position: absolute;
  left: 60px;
  z-index: 1;
  border: #000 1px solid;
}
.bibitem:before { content: "["; }
.bibitem:after { content: "]"; }
.bibitem { font-size:small; }
.bibitem a { color:gray; }
.title { font-weight:bold; }
.authors { font-variant: small-caps; }
a.doi:before { content: "doi:"; }
a.doi { color:gray; font-family:"monospace" }
.misc { font-size:small;}
EOF

my $preamble1 = << "EOF";
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
 PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title></title>
EOF
my $preamble2 = << "EOF";
</head>
<body>
EOF

my $js = << 'EOF';
    hide_blocks();
    var visible_block = 0;

    function hide_blocks() {
      all_divs = document.getElementsByTagName("div");
      for (var i = 0; i < all_divs.length; i++) {
        if (all_divs[i].className == "block_link") {
          all_divs[i].style.display = "inline";
        } else if (all_divs[i].className == "abstract") {
          all_divs[i].style.display = "none";
          all_divs[i].style.position = "absolute";
          all_divs[i].style.left = "60px";
          all_divs[i].style.zIndex = 1;
          all_divs[i].style.border = "#000 1px solid";
          all_divs[i].style.width = "50%";
        }
      }
    }

    function block_visible(id) {
      var m = document.getElementById("abstract_mask");
      if (visible_block) {
        var t = document.getElementById(visible_block);
        t.style.display = "none";
        if (m) {
          m.style.display = "none";
        }
        if (visible_block == id) {
          visible_block = 0;
          return;
        }
        visible_block = 0;
      }
      var e = document.getElementById(id);
      if (e) {
         e.style.display = "block";
         visible_block = id;
         if (m) {
           m.onclick = function() { block_visible(id); };
           m.style.display = "block";
         }
      }
    }
EOF

my $postamble = << "EOF";
</body>
</html>
EOF



print $preamble1 unless $params->{'no-frame'};
print '<style type="text/css">', $css, '</style>' unless $params->{'no-css'};
print $preamble2 unless $params->{'no-frame'};
print '<div id="abstract_mask"></div>', "\n" unless $params->{'no-js'} && $params->{'no-frame'};
my $prev_year = '';
for my $key (sort {- ($entries->{$a}->{'sort'} cmp $entries->{$b}->{'sort'}) } keys %$entries) {
    my $i = $entries->{$key};
    if ($prev_year ne $i->{'year'}) {
        $prev_year = $i->{'year'};
        print "<h2 class=\"year\">$prev_year</h2>\n";
    };
    print $i->{'html'};
}

print '<script type="text/javascript"> /* <![CDATA[ */ ', "\n", $js, ' /* ]]> */ </script>' unless $params->{'no-js'};
print $postamble unless $params->{'no-frame'};

# vim:set et ts=4 sw=4 st=4:
